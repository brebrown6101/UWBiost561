[{"path":"https://brebrown6101.github.io/UWBiost561/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 UWBiost561 authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW1.html","id":"q0-survey","dir":"Articles","previous_headings":"","what":"Q0: Survey","title":"HW1","text":"Intent: question simply course logistics course instructor get know . Question 0A: Please let know preferred name preferred pronouns. Bre, //Question 0B: Please read syllabus entirety write, “read understood entire syllabus,” question. questions syllabus (example, homework submission policy collaboration policy), may ask . read understood entire syllabus Question 0C: , please briefly describe courses taken UW involve coding (language) far familiar/comfortable coding R. (Note: expect taken courses already.) taken BIOST 514 515 also taken R coding course undergraduate studies. pretty comfortable R still ton don’t know. Question 0D: hope learn course? (alright leave blank, helpful hear thoughts.) excited learn write code others can use.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW1.html","id":"q2-simulating-the-central-limit-theorem","dir":"Articles","previous_headings":"","what":"Q2: Simulating the Central Limit Theorem","title":"HW1","text":"Intent: question simple coding exercise demonstrate familiarity basic coding R. Load generate_data function using following code (one line). code sources generate_data function current R workspace. Question 2A: Read function (either URL provided typing generate_data console), one three sentences, describe input output provided function function . may use equations needed. function produces vector either equal 1, 2, 3. vector produced equal 1 creates normal distribution, vector equal 2 produces gamma distribution vector equal 3 produces chi square distribution. prints whatever distribution associated repeats process n times. Question 2B: now using generate_data function. Observe run following code, compute (random, empirical) mean dataset n=10 samples: Repeat code 10,000 times (.e., 10,000 trials, keeping n=10 trial), plot histogram 10,000 different empirical means 100 breaks (.e., breaks = 100). Repeat process n values 1, 2, 3, 5, 100, plot six histograms order increasing n. Figure @ref(fig:clt) shows desired plot aim reproduce. particular, reproduce X- Y-labels, title plot, plot layout. (Hint: might find par function useful, especially mar mfrow arguments, well paste function. See documentation par.) figure trying reproduce (without Sample watermark) Question 2B, barring dimensions/proportions figure randomness inherent simulation.  Question 2C: one three sentences, write plot reproduced helps verify Central Limit Theorem. plot shows take larger sample sizes, sampling distribution mean tends closer closer towards normal distribution.","code":"source(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW1_files/generate_data.R\") set.seed(1) mean(generate_data(n=10)) #> [1] 5.199818 set.seed(1)    num = c(1,2,3,5,10, 100)   par(mfrow = c(2, 3)) for(x in num) {  empmeans <- replicate(   10000, mean(generate_data(n=x))           )   hist(empmeans, main = paste(\"Sample Size of\", x), breaks = 100, xlab = \"Mean\")  }"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW1.html","id":"q3-basic-data-analysis","dir":"Articles","previous_headings":"","what":"Q3: Basic data analysis","title":"HW1","text":"Intent: question simple data analysis demonstrate familiarity perform basic operations R. question, ’ll load simple dataset related Alzheimer’s Disease (AD) research. data originates single-cell database study. However, since first homework, ’ll mainly work donor-level data instead cell-level data. brief descriptions variable: Donor.ID: anonymized ID donor donated brain AD research Age..Death: age donor passed away Sex: biological sex donor. (Kevin’s comment: study, seems like strictly Male Female…?) APOE4.Status: Y (yes) N () donor particular genetic variant known risk factor AD Cognitive.Status: Whether donor dementia based wide array cognitive assessments death Last.CASI.Score: last score donor , measured via CASI (specific set cognitive questions), death Braak: Different severities neuropathology based donor’s brain tissue, extracted donor’s consent death Hopefully, reminder carefully describe study variables dataset publish collaborate ! Question 3A: Describe, two four sentences, head(df) summary(df) results display. ‘head(df)’ results display first six rows data dataframe. summary(df) results display number inputs variable quartiles, mean, median, number NAs numerical variables. variable character variable, just displays classification. Question 3B: Use simple function print dimensionality df (.e., many rows columns ). class df? Question 3C: ’ll note summary(df), variable Age..Death character, even though numeric. values 90+. simple diagnostic, 1) replace 90+ values df$Age..Death 90, 2) convert df$Age..Death character numeric, 3) plot histogram df$Age..Death.  Figure @ref(fig:hist) shows desired plot aim reproduce. figure trying reproduce (without Sample watermark) Question 3C, barring dimensions/proportions figure . Question 3D: summary() function much useful columns df factors, characters. Write lines code convert variables Sex, APOE4.Status, Cognitive.Status, Braak factors. (take less 10 lines code.) Question 3E: new version df, finishing previous questions, show result summary(df). Figure @ref(fig:summary) shows desired output aim reproduce. intended output Question 3E. one sentence, describe summary (Question 3E) informative summary shown start Question 3. summary provides us many values category categorical variables like Braak, Cognitive Status, Sex, APOE4 Status. Changing age numerical value allows us see quartiles mean median. Question 3F: Using table() function, display relation Braak Cognitive.Status. Please look ?table (documentation table()) unfamiliar function. Question 3G: question slightly challenging. table() function useful many unique values (Last.CASI.Score). overcome , look documentation cut quantile functions. goal use table(), cut(), quantile() show relation quantiles Last.CASI.Score Cognitive.Status. want use na.rm=TRUE using quantile() function. Figure @ref(fig:table) shows desired output aim reproduce. intended output Question 3G. one two sentences, describe can learn relation Last.CASI.Score Cognitive.Status based result. can begin infer association dementia dementia CASI Score. table, seems participants don’t dementia tend score higher CASI test dementia.","code":"df <- read.csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW1_files/sea-ad.csv\")  head(df) #>     Donor.ID Age.at.Death    Sex APOE4.Status Cognitive.Status Last.CASI.Score #> 1 H19.33.004           80 Female            N      No dementia              85 #> 2 H20.33.001           82   Male            N      No dementia              97 #> 3 H20.33.002          90+ Female            N      No dementia              93 #> 4 H20.33.004           86   Male            Y         Dementia              80 #> 5 H20.33.005          90+ Female            N      No dementia              94 #> 6 H20.33.008          90+ Female            Y      No dementia              92 #>      Braak #> 1 Braak IV #> 2 Braak IV #> 3 Braak IV #> 4  Braak V #> 5 Braak IV #> 6  Braak V  summary(df) #>    Donor.ID         Age.at.Death           Sex            APOE4.Status       #>  Length:84          Length:84          Length:84          Length:84          #>  Class :character   Class :character   Class :character   Class :character   #>  Mode  :character   Mode  :character   Mode  :character   Mode  :character   #>                                                                              #>                                                                              #>                                                                              #>                                                                              #>  Cognitive.Status   Last.CASI.Score    Braak           #>  Length:84          Min.   :66.00   Length:84          #>  Class :character   1st Qu.:80.00   Class :character   #>  Mode  :character   Median :89.00   Mode  :character   #>                     Mean   :87.32                      #>                     3rd Qu.:95.00                      #>                     Max.   :99.00                      #>                     NA's   :15 dim(df) #> [1] 84  7 class(df) #> [1] \"data.frame\" df$Age.at.Death[df$Age.at.Death == \"90+\"] = 90 df$Age.at.Death <- as.numeric(df$Age.at.Death) hist(df$Age.at.Death, xlab = \"Donor Age\", main = \"Histogram of Donor Age\") df$Sex <- as.factor(df$Sex) df$APOE4.Status <- as.factor(df$APOE4.Status) df$Cognitive.Status <- as.factor(df$Cognitive.Status) df$Braak <- as.factor(df$Braak) summary(df) #>    Donor.ID          Age.at.Death       Sex     APOE4.Status #>  Length:84          Min.   :65.00   Female:51   N:59         #>  Class :character   1st Qu.:83.75   Male  :33   Y:25         #>  Mode  :character   Median :90.00                            #>                     Mean   :86.26                            #>                     3rd Qu.:90.00                            #>                     Max.   :90.00                            #>                                                              #>     Cognitive.Status Last.CASI.Score       Braak    #>  Dementia   :42      Min.   :66.00   Braak 0  : 2   #>  No dementia:42      1st Qu.:80.00   Braak II : 4   #>                      Median :89.00   Braak III: 6   #>                      Mean   :87.32   Braak IV :23   #>                      3rd Qu.:95.00   Braak V  :34   #>                      Max.   :99.00   Braak VI :15   #>                      NA's   :15 table(df$Braak, df$Cognitive.Status) #>             #>             Dementia No dementia #>   Braak 0          0           2 #>   Braak II         2           2 #>   Braak III        2           4 #>   Braak IV         4          19 #>   Braak V         20          14 #>   Braak VI        14           1 quantile(df$Last.CASI.Score, probs = seq(0, 1, 0.25), na.rm = TRUE) #>   0%  25%  50%  75% 100%  #>   66   80   89   95   99  Cut.Last.CASI.Score <- cut(df$Last.CASI.Score, breaks = c(66, 80, 89, 95,99), labels = c(\"(66-80]\", \"(80-89]\", \"(89-95]\", \"(95-99]\"), include.lowest = TRUE)  table(Cut.Last.CASI.Score, df$Cognitive.Status) #>                     #> Cut.Last.CASI.Score Dementia No dementia #>             (66-80]       17           1 #>             (80-89]       10           8 #>             (89-95]        2          15 #>             (95-99]        3          13"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"instructions","dir":"Articles","previous_headings":"","what":"Instructions","title":"BIOST 561: Homework 2","text":"instructions essential, please read carefully. Submit homework GitHub page RMarkdown (.Rmd) HTML files. Please answer question prompt show code (inline). , code visible knitted chunks. complete homework, may write HW2.Rmd file. (recommended complete homework R Studio, clicking Knit button knit homework.)","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"disclosures","dir":"Articles","previous_headings":"","what":"Disclosures","title":"BIOST 561: Homework 2","text":"Please disclose collaborated ’ve used ChatGPT (comparable AI tool) extent completing homework. See syllabus course expectations. (Hint: feel stuck homework, feel free consult ChatGPT. Often, need double-check responses ChatGPT verify correctness. advise ask ChatGPT generate minimal examples demonstrate use various functions, provide clear example function works.) Q2A consulted stackoverflow forum figure add row count title: https://stackoverflow.com/questions/74537067/adding--calculation---title---ggplot Q3C consulted R Charts article create heatmap using ggplot2: https://r-charts.com/correlation/heat-map-ggplot2/","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"q0-setting-up-your-uwbiost561-package","dir":"Articles","previous_headings":"","what":"Q0: Setting up your UWBiost561 package","title":"BIOST 561: Homework 2","text":"need write anything part question. Question 0A: Install tidyverse. (involve typing install.packages(\"tidyverse\") R console. need put Markdown file.) Question 0B: Update DESCRIPTION R package. , file called DESCRIPTION UWBiost561 package. look something like : Add following lines DESCRIPTION include bookdown, tidyverse, ggplot2. look like something like: Save file close . Question 0C: Make sure can load package. (need bookdown package knit homework, similar HW1.) (might throw warning “conflicted package.” can ignore .) Question 0D: Double check following things R package: HW1.html, HW1.Rmd, HW2.Rmd (file), --created HW2.html files vignettes folder R package. .gitignore file vignettes folder. (Please delete .gitignore file one exists.)","code":"Suggests:    knitr,   rmarkdown Suggests:    knitr,   rmarkdown,   bookdown,   tidyverse,   ggplot2 library(bookdown) library(tidyverse) #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.4     ✔ readr     2.1.5 #> ✔ forcats   1.0.0     ✔ stringr   1.5.1 #> ✔ ggplot2   3.5.2     ✔ tibble    3.2.1 #> ✔ lubridate 1.9.4     ✔ tidyr     1.3.1 #> ✔ purrr     1.0.4      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ dplyr::filter() masks stats::filter() #> ✖ dplyr::lag()    masks stats::lag() #> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors library(ggplot2)"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"q1-practice-using-tibbles","dir":"Articles","previous_headings":"","what":"Q1: Practice using tibbles","title":"BIOST 561: Homework 2","text":"Intent: question give basic practice using tibbles (tidyverse way analyzing data, overall). question, ’ll using two datasets collect various statistics countries many years. first dataset gt package (see https://search.r-project.org/CRAN/refmans/gt/html/countrypops.html), formatted specifically homework. can loaded following code: (Note ’re reading data using readr::read_csv function, automatically converts csv data tibble. read.csv function. See ?readr::read_csv ?read.csv.) country_population contains following columns: iso3c: Three-letter country code (see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country: Country name year: Year statistic collected population: Population, based World Bank estimate next dataset https://paldhous.github.io/NICAR/2017/r-analysis.html, also formatted specifically homework. can loaded following code: country_birth contains following columns: iso2c: Two-letter country code iso3c: Three-letter country code year: Year statistic collected life_expect: Life expectancy birth, years. birth_rate: Live births year per 1,000 people neonat_mortal_rate: Neonatal mortality rate: babies dying reaching 28 days age per 1,000 live births given year question allow practice basic data manipulation two tibble objects. Question 1A: manipulating country_population data question. goal following: Select rows years 1990 2010 (inclusive). , compute mean population across years country country (defining new variable called mean_population, via group_by() summarize() functions). Figure @ref(fig:population) shows first two rows desired output. output trying reproduce (without Sample watermark) Question 1A. Question 1B: manipulating country_birth data question. goal following: Select rows years 1990 2010 (inclusive), keep iso3c, year, life_expect columns, drop rows NA 3 columns. , compute minimum maximum life expectancy (named new columns called min_life_expect max_life_expect) country across years (via summarize() function), finally, create new column called range_life_expect number years min_life_expect max_life_expect country (via mutate() function). Figure @ref(fig:birth) shows first two rows desired output. output trying reproduce (without Sample watermark) Question 1B. Question 1C: now combine country_population country_birth via join. Specifically, using inner_join() function, combine datasets iso3c variable, call new tibble object country_both. Print first 10 rows country_both. many rows columns country_both?","code":"country_population <- readr::read_csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/country_population.csv\") #> Rows: 13545 Columns: 4 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (2): iso3c, country #> dbl (2): year, population #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. country_population #> # A tibble: 13,545 × 4 #>    iso3c country  year population #>    <chr> <chr>   <dbl>      <dbl> #>  1 ABW   Aruba    1960      54608 #>  2 ABW   Aruba    1961      55811 #>  3 ABW   Aruba    1962      56682 #>  4 ABW   Aruba    1963      57475 #>  5 ABW   Aruba    1964      58178 #>  6 ABW   Aruba    1965      58782 #>  7 ABW   Aruba    1966      59291 #>  8 ABW   Aruba    1967      59522 #>  9 ABW   Aruba    1968      59471 #> 10 ABW   Aruba    1969      59330 #> # ℹ 13,535 more rows country_birth <- readr::read_csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/country_birth.csv\") #> Rows: 5486 Columns: 5 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (1): iso3c #> dbl (4): year, life_expect, birth_rate, neonat_mortal_rate #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. country_birth #> # A tibble: 5,486 × 5 #>    iso3c  year life_expect birth_rate neonat_mortal_rate #>    <chr> <dbl>       <dbl>      <dbl>              <dbl> #>  1 AND    1994          NA       10.9                3.2 #>  2 AND    1995          NA       11                  3   #>  3 AND    2006          NA       10.6                1.9 #>  4 AND    2007          NA       10.1                1.8 #>  5 AND    1996          NA       10.9                2.8 #>  6 AND    1993          NA       11.4                3.4 #>  7 AND    1997          NA       11.2                2.6 #>  8 AND    1998          NA       11.9                2.4 #>  9 AND    2008          NA       10.4                1.8 #> 10 AND    2009          NA        9.9                1.7 #> # ℹ 5,476 more rows country_population <- country_population %>%   filter(between(year, 1990, 2010)) %>%   group_by(iso3c, country) %>%   summarize(mean_population = sum(population)/length(year)) %>% mutate(mean_population = round(mean_population, 0)) #> `summarise()` has grouped output by 'iso3c'. You can override using the #> `.groups` argument.               print(head(country_population,2)) #> # A tibble: 2 × 3 #> # Groups:   iso3c [2] #>   iso3c country     mean_population #>   <chr> <chr>                 <dbl> #> 1 ABW   Aruba                 85839 #> 2 AFG   Afghanistan        19819866 country_birth <- country_birth %>%   filter(between(year, 1990, 2010)) %>%   select(iso3c, year, life_expect) %>%   filter(!is.na(iso3c), !is.na(year), !is.na(life_expect)) %>%   group_by(iso3c) %>%   summarize(     min_life_expect = min(life_expect),     max_life_expect = max(life_expect)) %>% mutate(range_life_expect = round((max_life_expect - min_life_expect), 2)) print(head(country_birth,2)) #> # A tibble: 2 × 4 #>   iso3c min_life_expect max_life_expect range_life_expect #>   <chr>           <dbl>           <dbl>             <dbl> #> 1 ABW              73.4            75.0              1.56 #> 2 AFG              49.9            59.0              9.11 country_both = inner_join(   country_population,   country_birth,   join_by(iso3c), )  print(head(country_both,10)) #> # A tibble: 10 × 6 #> # Groups:   iso3c [10] #>    iso3c country              mean_population min_life_expect max_life_expect #>    <chr> <chr>                          <dbl>           <dbl>           <dbl> #>  1 ABW   Aruba                          85839            73.4            75.0 #>  2 AFG   Afghanistan                 19819866            49.9            59.0 #>  3 AGO   Angola                      16829911            41.1            50.7 #>  4 ALB   Albania                      3095489            71.9            77.0 #>  5 ARE   United Arab Emirates         3858774            71.7            76.7 #>  6 ARG   Argentina                   36972314            71.5            75.5 #>  7 ARM   Armenia                      3211816            67.7            74.2 #>  8 ATG   Antigua and Barbuda            74385            71.2            75.3 #>  9 AUS   Australia                   19200991            77.0            81.7 #> 10 AUT   Austria                      8057573            75.6            80.6 #> # ℹ 1 more variable: range_life_expect <dbl> dim(country_both) #> [1] 202   6"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"q2-practice-using-ggplot-via-scatterplots-and-facets","dir":"Articles","previous_headings":"","what":"Q2: Practice using ggplot via scatterplots and facets","title":"BIOST 561: Homework 2","text":"Intent: question give basic practice using ggplot, mainly plotting scatterplots faceting plots. question, ’ll using dataset penguins Palmer Archipelago https://allisonhorst.github.io/palmerpenguins/reference/penguins.html. ’ve processed lightly homework. can see original documentation describing variables dataset. following code makes basic scatter plot. improving plot following sub-questions.  Question 2A: penguins dataset, change x-axis label y-axis label say Bill Depth (mm) Bill length (mm) respectively, well title plot write Relation among ??? penguins, use code count many rows penguins automatically (place ???). Additionally, color point based species, Adelie color cornflowerblue, Chinstrap color coral2, Gentoo color goldenrod3. (Hint: likely need scale_color_manual(), labs(), paste() functions.) (can see http://www.stat.columbia.edu/tzheng/files/Rcolor.pdf see color names come .) Figure @ref(fig:scatterplot) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 2A.  Question 2B: now make following changes: 1) facet scatterplot based species, 2) add linear regression fit species (regression bill_length_mm onto bill_depth_mm) plot linear regression fit, 3) changing transparency points 50% transparent (.e., alpha=0.5). (Hint: question bit tricky since many things going . likely need geom_smooth() facet_wrap() functions.) Figure @ref(fig:facet) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 2B.","code":"penguins <- readr::read_csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/palmerpenguins.csv\") #> Rows: 333 Columns: 8 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (3): species, island, sex #> dbl (5): bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. penguins #> # A tibble: 333 × 8 #>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g #>    <chr>   <chr>              <dbl>         <dbl>             <dbl>       <dbl> #>  1 Adelie  Torgersen           39.1          18.7               181        3750 #>  2 Adelie  Torgersen           39.5          17.4               186        3800 #>  3 Adelie  Torgersen           40.3          18                 195        3250 #>  4 Adelie  Torgersen           36.7          19.3               193        3450 #>  5 Adelie  Torgersen           39.3          20.6               190        3650 #>  6 Adelie  Torgersen           38.9          17.8               181        3625 #>  7 Adelie  Torgersen           39.2          19.6               195        4675 #>  8 Adelie  Torgersen           41.1          17.6               182        3200 #>  9 Adelie  Torgersen           38.6          21.2               191        3800 #> 10 Adelie  Torgersen           34.6          21.1               198        4400 #> # ℹ 323 more rows #> # ℹ 2 more variables: sex <chr>, year <dbl> penguins %>%   ggplot(aes(x = bill_depth_mm, y = bill_length_mm)) +   geom_point() z = nrow(penguins) cols <- c(\"Adelie\" = \"cornflowerblue\", \"Chinstrap\"= \"coral2\", \"Gentoo\" = \"goldenrod3\") penguins %>%   ggplot(aes(x = bill_depth_mm, y = bill_length_mm)) +   geom_point(aes(color=species)) + labs(title = paste(\"Relation Among\", z,  \"Penguins\")) + xlab(\"Bill Depth (mm)\") + ylab(\"Bill length (mm)\") + scale_color_manual(values = cols) z = nrow(penguins) cols <- c(\"Adelie\" = \"cornflowerblue\", \"Chinstrap\"= \"coral2\", \"Gentoo\" = \"goldenrod3\") penguins %>%    ggplot(aes(x = bill_depth_mm, y = bill_length_mm)) +   facet_wrap(. ~ species) +   geom_point(aes(color=species, alpha = 0.5)) + geom_smooth(method =\"lm\", se = FALSE, aes(color = species)) + labs(title = paste(\"Relation Among\", z,  \"Penguins\")) + xlab(\"Bill Depth (mm)\") + ylab(\"Bill length (mm)\") + scale_color_manual(values = cols) #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"q3-practice-using-ggplot-via-heatmaps","dir":"Articles","previous_headings":"","what":"Q3: Practice using ggplot via heatmaps","title":"BIOST 561: Homework 2","text":"Intent: question give basic practice using ggplot, mainly plotting heatmaps. also see generate_random_graph() function future homeworks. Run following code load generate_random_graph(), generates adj_mat, random adjacency matrix (corresponding graph 20 nodes). row/column adj_mat corresponds one 20 nodes, value 0 1 denotes lack presence edge two nodes, respectively. Question 3A: Read provided generate_random_graph() works (either typing generate_random_graph R console reading code https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R). three five sentences, describe generate_random_graph() . Generate_random_graph() first checks n greater zero, clique_fraction amount greater equal zero less equal one, density also greater equal zero less equal one. , generates unsymmetric matrix sample values chosen either 1 edge 0 edge, chosen n^2 times, probability weights 1-density_low, density_low, replacement. matrix symmetrized taking matrix plus transpose setting diagonal values matrix equal one. forms clique top left, randomizes order nodes,computes topological reverse order. Question 3B: now write code produce heatmap visualize adj_mat. can happen, though, need one function convert adj_mat “long form,” necessity visualizing plot heatmap ggplot. See https://r-graph-gallery.com/heatmap.html. done via provided pivot_longer_heatmap() function: Read pivot_longer_heatmap() function (either typing pivot_longer_heatmap R console reading code https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R). three five sentences, describe pivot_longer_heatmap() . Specifically, output pivot_longer_heatmap() relate adj_mat? (Hint: question, might helpful manually run function line--line R console see line code . hardest part question understanding pivot_longer function . Look documentation function via ?tidyr::pivot_longer. might also helpful recall, R console, values adj_mat[1,1], adj_mat[1,2], adj_mat[1,3], … . look similar rows mat_long?) pivot_longer_heatmap() turns adj_mat tibble, rearranges matrix making X equal vertical nodes Y equal horizontal nodes. goes every ordered pair first row X = 1, Y = 1 equal adj_mat[1,1] X=1, Y=2 equal adj_mat[1,2] Y =20, goes next adj_mat row X becomes 2. continues goes 20 rows X every ordered pair combination Y. , variable Value correlates entry ordered pair originally displayed adj_mat. Question 3C: Now ready write code visualize mat_long heatmap. Write code using ggplot’s functions . want color 0 values palegoldenrod 1 values coral2. Please set aspect ratio plot 1:1 (.e., “boxes” squares) via coord_fixed() function. two four sentences, describe plot made relates adj_mat. (Hint: question tricky, even though need roughly 7 functions. likely want use geom_tile() scale_fill_manual() functions.) Figure @ref(fig:adjmat) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 3C.  y-axis heatmap corresponds rows adj_mat, x-axis corresponds columns. square heatmap equivalent entry matrix relative ordered pair. [1,1] heatmap equivalent adj_mat[1,1]. value adj_mat[x,y] 1, heatmap colors relative square coral, else goldenrod. Question 3D: Congratulations! working pipeline visualize adjacency matrix. last question, combine functions visualize following: can double-check see line code permutes rows columns. actual “graph” change (since ordering rows/columns arbitrary). Use provided pivot_longer_heatmap() function code Question 3C visualize adj_mat2. (mainly copy-pasting code previous questions now applying adj_mat2.)  see dense set red blocks bottom-left corner heatmap. two sentences, plot tell us adj_mat2, turn, adj_mat? (Hint: Question 4 give context answer question.) Figure @ref(fig:adjmat2) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 3D. tells us collection connected nodes graph adj_mat2 adj_mat2[1,1] adj_mat2[10,10]. tells us clique adj_mat evident rows columns permuted reverse topological order.","code":"source(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R\") set.seed(0) result <- generate_random_graph(n = 20,                                 clique_fraction = 0.5,                                 density_low = 0.1) adj_mat <- result$adj_mat dim(adj_mat) #> [1] 20 20 reverse_adj <- adj_mat[result$rev_order, result$rev_order] adj_mat[1:5, 1:5] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    0    1    0    0 #> [2,]    0    1    1    1    1 #> [3,]    1    1    1    0    0 #> [4,]    0    1    0    1    0 #> [5,]    0    1    0    0    1 mat_long <- pivot_longer_heatmap(adj_mat) mat_long #> # A tibble: 400 × 3 #>        X     Y Value #>    <int> <dbl> <dbl> #>  1     1     1     1 #>  2     1     2     0 #>  3     1     3     1 #>  4     1     4     0 #>  5     1     5     0 #>  6     1     6     1 #>  7     1     7     0 #>  8     1     8     0 #>  9     1     9     0 #> 10     1    10     0 #> # ℹ 390 more rows mat_long %>% ggplot(aes(x = X, y = Y, fill = factor(Value))) +   geom_tile() +   coord_fixed(ratio=1:1) +   scale_fill_manual(values = c(\"0\"=\"palegoldenrod\", \"1\"=\"coral2\"), name = \"Value\") + ylab(\"Row\") + xlab(\"Column\") adj_mat2 <- result$adj_mat[result$rev_order, result$rev_order] mat2_long <- pivot_longer_heatmap(adj_mat2) mat2_long %>% ggplot(aes(x = X, y = Y, fill = factor(Value))) +   geom_tile() +   coord_fixed(ratio=1:1) +   scale_fill_manual(values = c(\"0\"=\"palegoldenrod\", \"1\"=\"coral2\"), name = \"Value\") + ylab(\"Row\") + xlab(\"Column\")"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"q4-planning-for-the-next-homework-thinking-how-to-test-a-function","dir":"Articles","previous_headings":"","what":"Q4: Planning for the next homework – thinking how to test a function","title":"BIOST 561: Homework 2","text":"Intent: question get started think testing function. Question 3 demonstrates “planted clique” – might clique random graph (.e., collection connected nodes). clique might evident first glance (demonstrated Question 3C), permute rows columns (done Question 3D), clique quite apparent. (Lecture 4, go basics thinking graphs adjacency matrices. Please watch Panopto recording Canvas want context.) Suppose teammate gave function find maximal clique adjacency matrix (.e., set nodes forms largest clique). told typical size characteristics adjacency matrices beforehand. job make sure function correct since teammate give function manager, give another division company use. performance review depend highly whether people company can reliably use function. short paragraph, write ways ensure teammate’s function “correct.” Please list least four different ways can test function. can interpret notion “correct” liberally – question purposely framed open-ended. (purposely giving implementation function. Please use ChatGPT specific question.) (curious, “Maximal Clique Problem” (MCP), classic example “hard” problem Computer Science theory. See https://arxiv.org/abs/2403.09742. need read paper complete question – ’s simply additional reading curious students.) Check test matrix cliques see returns answer. , means correct identifying cliques. Try passing something matrix, like data frame, function see returns answer. , correctly checking data structure needs used function. Pass test matrix two large cliques, one just slightly larger . function incorrectly identifies clique maximal clique, incorrect. Pass larger larger matrices function make sure can handle larger calculations without overflowing.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW2.html","id":"q5-feedback-optional","dir":"Articles","previous_headings":"","what":"Q5: Feedback (Optional)","title":"BIOST 561: Homework 2","text":"“question” additional way students communicate instructors. include positive feedback topics enjoyed learning module, critiques course difficulty/pacing, questions/confusions course material. feedback can help shape course rest quarter future years. Please mindful polite providing feedback. may leave question blank.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"instructions","dir":"Articles","previous_headings":"","what":"Instructions","title":"BIOST 561: Homework 3","text":"instructions essential, please read carefully. Submit homework GitHub page RMarkdown (.Rmd) HTML files. Please answer question prompt show code (inline). , code visible knitted chunks. complete homework, may write HW3.Rmd file. (recommended complete homework R Studio, clicking Knit button knit homework.)","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"disclosures","dir":"Articles","previous_headings":"","what":"Disclosures","title":"BIOST 561: Homework 3","text":"Please disclose collaborated ’ve used ChatGPT (comparable AI tool) extent completing homework. See syllabus course expectations. used ChatGPT develop functions. (Note: homework substantially challenging Homework 2 since homework much open-ended. feel stuck homework, feel free consult ChatGPT. ChatGPT can give strategies tackling problem, code tackle problem, explanation step code works. Try using ChatGPT part workflow. homework get realize writing “code gets job done” (important) tiny part means “strong coder.”)","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"note-about-the-homework","dir":"Articles","previous_headings":"","what":"Note about the homework","title":"BIOST 561: Homework 3","text":"Note: R code homework homework. mainly write .R files inside R tests folders. Therefore, need show little code inside R Markdown file. need write things inside R Markdown file questions explicitly ask .","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"q1-designing-a-function-to-generate-random-graphs-with-partial-cliques","dir":"Articles","previous_headings":"","what":"Q1: Designing a function to generate random graphs with partial cliques","title":"BIOST 561: Homework 3","text":"Intent: intent question : 1) give practice putting R functions UWBiost561 package, 2) help create ways test function Question 3 meaningfully. Recall generate_random_graph() function used Homework 2. (deliberately open-ended) goal question design function generate_partial_clique() generates random adjacency matrix large partial clique, necessarily (fully connected) clique. Question 1A: Create function generate_partial_clique() inside UWBiost561 package inside file called generate_partial_clique.R inside R folder. (nothing report question. code R folder, R Markdown file.) Specifications function overall: function must called generate_partial_clique. function must file called generate_partial_clique.R R folder within UWBiost561 package. write additional “helper” functions generate_partial_clique() depends , additional functions must also generate_partial_clique.R. , generate_partial_clique.R “self-contained.” code must written R. (write code C++, Java, Python.) Specifications function inputs: first, second, third arguments generate_partial_clique() must called n, clique_fraction, clique_edge_density respectively. function check n argument positive integer. argument represents number nodes graph (literal sense, number rows columns outputted adjacency matrix). function check clique_fraction argument single numeric 0 1 (inclusive). argument represents fraction nodes (n nodes) part partial clique. (, least round(n*clique_fraction) nodes part partial clique.) function check clique_edge_density argument single numeric 0 1 (inclusive). argument represents edge density among nodes clique. (example, generate_random_graph() used Homework 2 essentially clique_edge_density=1, adjacency matrix worked Homework 2 (fully connected) clique.) Specifically, means partial clique m=round(n*clique_fraction) nodes, (fully connected) clique m*(m-1)/2 (.e., m choose 2) edges. partial clique edge density clique_edge_density instead least round(clique_edge_density*m*(m-1)/2) edges among m nodes. function may take arguments, every argument n, clique_fraction clique_edge_density must default value. use function, user need set argument aside n, clique_fraction clique_edge_density. Specifications function outputs: must output list. first named element must specifically adj_mat. random adjacency matrix construct partial clique. Specifically, adj_mat symmetric matrix values 0 1, 2) 1’s along diagonal, 3) row- column-names. (construction, partial clique consisting least round(clique_fraction*n) nodes edge density clique_edge_density.) may optionally return additional outputs (within reason) function might need testing/debugging. Note: purposely specify necessary ingredients create random graph. can design function long satisfies required specifications. However, realize start testing function Question 3, ways create graphs partial cliques “easy” “aren’t useful” testing compute_maximal_partial_clique() Question 2. Question 1B: Following demo showed Lecture 4, create ROxygen skeleton generate_partial_clique() function inside generate_partial_clique.R file. Write meaningful documentation generate_partial_clique() function. Importantly, exported via @export tag. (nothing report question. ROxygen skeleton R Markdown file) Question 1C: Install R package. can using R Studio running devtools::install() R console. (nothing report question. R Markdown file.) might find https://docs.google.com/document/d/17lskKfgMdLSi3SroQMdodqmHWjxeyNPnXTxM3beoCM8/edit?usp=sharing useful difficulty installing UWBiost561 package. Question 1D: homework’s R Markdown file, show generate_partial_clique() function works. Specifically, run following lines. (copy-pasting following R chunk, remove eval = FALSE tag.) get full marks markdown shows code chunk shows code outputted matrix res$adj_mat . Congratulations! ’ve just made function R package!","code":"source(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R\") generate_random_graph #> function (n, clique_fraction = 0.2, density_low = 0.1)  #> { #>     stopifnot(n%%1 == 0, n >= 0, clique_fraction >= 0, clique_fraction <=  #>         1, density_low >= 0, density_low <= 1) #>     adj_mat <- matrix(sample(x = c(0, 1), size = n^2, prob = c(1 -  #>         density_low, density_low), replace = TRUE), nrow = n,  #>         ncol = n) #>     adj_mat <- adj_mat + t(adj_mat) #>     adj_mat[adj_mat > 0] <- 1 #>     diag(adj_mat) <- 1 #>     clique_size <- ceiling(n * clique_fraction) #>     adj_mat[1:clique_size, 1:clique_size] <- 1 #>     sample_idx <- sample(1:n) #>     adj_mat <- adj_mat[sample_idx, sample_idx] #>     rev_order <- sapply(1:n, function(i) { #>         which(sample_idx == i) #>     }) #>     return(list(adj_mat = adj_mat, rev_order = rev_order)) #> } library(UWBiost561) set.seed(0) simulation <- UWBiost561::generate_partial_clique(   n = 10,   clique_fraction = 0.5,   clique_edge_density = 0.9 )  simulation$adj_mat #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    1    1    0    1    0    0    1    0    1     0 #>  [2,]    1    1    0    1    0    0    1    0    0     0 #>  [3,]    0    0    1    0    0    0    0    0    0     0 #>  [4,]    1    1    0    1    0    0    1    0    1     0 #>  [5,]    0    0    0    0    1    0    0    0    0     0 #>  [6,]    0    0    0    0    0    1    0    0    0     0 #>  [7,]    1    1    0    1    0    0    1    0    1     0 #>  [8,]    0    0    0    0    0    0    0    1    0     0 #>  [9,]    1    0    0    1    0    0    1    0    1     0 #> [10,]    0    0    0    0    0    0    0    0    0     1"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"q2-designing-a-function-to-find-the-maximal-partial-clique","dir":"Articles","previous_headings":"","what":"Q2: Designing a function to find the maximal partial clique","title":"BIOST 561: Homework 3","text":"Intent: intent question : 1) give practice developing function “open-ended”, 2) emulate realistic coding experience. code write play huge role Homework 4, look function fellow students write vice versa. Question 2A: Create function compute_maximal_partial_clique() inside UWBiost561 package computes largest partial clique given adjacency matrix adj_mat required edge density alpha. (nothing report question. code R folder, R Markdown file.) Illustration adjacency matrix (left), , reorder nodes (right, similar HW2), ’ll see first 9 nodes 95% partial clique. Note: maximal partial clique (.e., specific set nodes) might unique! always uniquely defined size maximal partial clique valid inputs adj_mat alpha. (adj_mat empty graph, .e., just diagonal matrix, maximal partial clique size 1: node clique .) Realistically, function sometimes get correct maximal partial clique (even unique) since “correct” maximal partial clique requires unreasonable computationally resources. Effectively, correct answer task. goal instead give reasonable answer (define ). coding tasks data analyses encounter “real world” definitive, well-defined “correct” answer! Specifications function overall: function must called compute_maximal_partial_clique. function must file called compute_maximal_partial_clique.R R folder within UWBiost561 package. write additional “helper” functions compute_maximal_partial_clique() depends , additional functions must also compute_maximal_partial_clique.R. , compute_maximal_partial_clique.R “self-contained.” code must written R. (write code C++, Java, Python.) Time efficiency: input adj_mat 30 30 (.e., 30 nodes), method take 30 seconds complete . Specifications function inputs: first second arguments compute_maximal_partial_clique() must called adj_mat alpha respectively. function check adj_mat argument : 1) symmetric matrix values 0 1, 2) 1’s along diagonal, 3) row- column-names, 4) 5 50 rows/columns (inclusive). function check alpha argument : 1) single numeric (.e., length 1), 2) value 0.5 1 (inclusive). function may take arguments, every argument adj_mat alpha must default value. use function, user need set argument aside adj_mat alpha. Specifications function outputs: must output list. list must contain least two named elements, specifically first second elements: first named element must specifically clique_idx. numeric vector index numbers corresponding nodes (.e., values 1 nrow(adj_mat)) function deems maximum partial clique. vector duplicate elements, must positive integers, largest value exceed nrow(adj_mat). Specifically, means function elect adj_mat[clique_idx,clique_idx] maximal partial clique, meaning: 1) m=length(clique_idx), (sum(adj_mat[clique_idx,clique_idx])-m)/2 >= alpha*m*(m-1)/2, ensures number edges among nodes clique_idx (100*alpha)% full clique size m, 2) size clique_idx (reasonably) increased without making valid partial clique density alpha. (Remember: easy ensure condition #1, hard guarantee condition #2.) second named element must specifically edge_density. percentage edges adj_mat among nodes clique_idx. (calculation given demo code .) Specifically, number 0 1 (inclusive), (computed correctly length clique_idx larger one) always greater equal alpha construction. may optionally return additional outputs (within reason) function might need testing/debugging. Rules/Guidelines using external packages: function can use packages CRAN. (, packages GitHub Bioconductor.) best knowledge, code also use functions depend language C C++. (packages functions use invoke Java Python code.) use function directly solves maximal partial clique. (Please ask Canvas discussions unsure function intend use violates rule.) Please (best can) design code depend packages possible. rough skeleton compute_maximal_partial_clique() might look like: Note: expected know many “algorithms” course. Hence, 1) understand task 2) still trying figure approach question, please consult ChatGPT. Lectures 5 6 give live demonstrations “code ChatGPT.” feel overwhelmed question, can use ChatGPT help . (okay long function works follows specifications question – might need modify ChatGPT’s code.) However, can guarantee ChatGPT give anywhere close “optimal” solution task (many senses word). problem provably “correct solution can feasibly used.” Hence, feel courageous know algorithms, can go rabbit hole see design better algorithm. assessing implementation based demonstrating “good faith effort,” based whether function outputs “correct” maximal partial clique. receive full credit function works, provides reasonable outputs, passes unit tests (Question 3). Question 2B: Similar Question 1B 1C, create ROxygen skeleton compute_maximal_partial_clique() function inside compute_maximal_partial_clique.R file. Write meaningful documentation compute_maximal_partial_clique() function. Importantly, exported via @export tag. , install UWBiost561 package . (nothing report question. ROxygen skeleton R Markdown file) ROxygen skeleton include two five sentences method works. Question 2C: Demonstrate (R Markdown file) compute_maximal_partial_clique() works random adjacency matrix outputted function generate_partial_clique(). Specifically, run following lines. (copy-pasting following R chunk, remove eval = FALSE tag.) question purposefully open-ended. goal simply show output compute_maximal_partial_clique() function based adjacency matrix generate_partial_clique() “reasonable.”","code":"# This is NOT a good implementation. # This is solely for demonstration. # This lousy function simply picks a random set of nodes. # It doesn't actually compute the valid partial clique! compute_maximal_partial_clique <- function(adj_mat, alpha){   n <- nrow(adj_mat)   clique_idx <- sample(1:n, size = ceiling(n/2))   m <- length(clique_idx)      edge_density_numerator <- (sum(adj_mat[idx,idx]) - m)/2   edge_density_denominator <- m*(m-1)/2   edge_density <- edge_density_numerator/edge_density_denominator      return(list(clique_idx = clique_idx,               edge_density = edge_density)) } library(UWBiost561) set.seed(0) simulation <- UWBiost561::generate_partial_clique(   n = 10,   clique_fraction = 0.5,   clique_edge_density = 0.9 )  adj_mat <- simulation$adj_mat  res <- UWBiost561::compute_maximal_partial_clique(   adj_mat = adj_mat,   alpha = 0.9 ) res #> $clique_idx #> [1] 1 2 4 7 9 #>  #> $edge_density #> [1] 0.9"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"q3-developing-unit-tests-for-your-functions","dir":"Articles","previous_headings":"","what":"Q3: Developing unit tests for your functions","title":"BIOST 561: Homework 3","text":"Intent: intent question give experience writing unit tests inside UWBiost561 package. Question 3A: Following overview Lecture 5, well additional walkthrough https://docs.google.com/document/d/17lskKfgMdLSi3SroQMdodqmHWjxeyNPnXTxM3beoCM8/edit?usp=sharing, create tests folder UWBiost561 package contains testthat.R file (shown ) well testthat folder. (nothing report question.) Question 3B: Write least two unit tests generate_partial_clique() function inside file called test_generate_partial_clique.R within testthat folder. (nothing report question. code tests/testthat folder, R Markdown file.) Question 3C: Writing least five unit tests compute_maximal_partial_clique() function inside file called test_compute_maximal_partial_clique.R within testthat folder. Based “List types unit-tests” page Lecture 5, ensure five unit tests “different category.” (nothing report question. code tests/testthat folder, R Markdown file.) pointers: use generate_partial_clique() within tests compute_maximal_partial_clique(). Since constructing random adjacency matrix partial clique least edge density clique_edge_density size round(n*clique_fraction), expect “simple” random adjacency matrices, compute_maximal_partial_clique() can recover partial clique constructed. Question 3D: Run devtools::test() R package UWBiost561 ’re R project. (nothing report question. code R console, R Markdown file.)","code":"# This is what your testthat.R file should contain library(testthat) library(UWBiost561)  testthat::test_check(\"UWBiost561\")"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"q4-finalizing-your-r-package","dir":"Articles","previous_headings":"","what":"Q4: Finalizing your R package","title":"BIOST 561: Homework 3","text":"Intent: intent question experience basics making R package. Question 4A: Fix DESCRIPTION file needed. Importantly, involves adding R package dependencies generate_partial_clique() compute_maximal_partial_clique() depend . (none, don’t need worry .) also replace default author, package title, description something meaningful. (nothing report question.) Question 4B: R project UWBiost561 package, run command usethis::use_mit_license() R console. (nothing report question.) point, R package following. File specifically called generate_partial_clique.R File specifically called compute_maximal_partial_clique.R File specifically called testthat.R File specifically called test_generate_partial_clique.R File specifically called test_compute_maximal_partial_clique.R Multiple files, including files HW1.Rmd, HW1.html, HW2.Rmd, HW2.html, HW3.Rmd, HW3.html (analogously named) File specifically called DESCRIPTION File specifically called LICENSE File specifically called .Rbuildignore (potential files) Question 4B: Run devtools::check(). Ensure errors, ’s okay don’t want fix warnings. (devtools::check() also automatically generate man folder documentation converted ROxygen code NAMESPACE file.) might take fix errors devtools::check() complains – advise using Google determine exactly unhappy , can ask Canvas Discussion board. (nothing report question. code R console, R Markdown file.) Question 4C: Include screenshots devtools::check() result R Markdown file. (guideline, one screenshot show first 20--lines devtools::check() results, second screenshot show last 20--lines results.) can use knitr::include_graphics() function include figures inside R Markdown file. intent question provide “evidence” devtools::check() went smoothly. need worry screenshots show specifically. Figure @ref(fig:check1) @ref(fig:check2) shows screenshots trying reproduce. first screenshot trying reproduce (without Sample watermark) Question 4C. second screenshot trying reproduce (without Sample watermark) Question 4C. Question 4D: Please include following code chunk’s result Markdown file. (copy-pasting following R chunk, remove eval = FALSE tag.) useful (Kevin) assess packages R version using.","code":"devtools::session_info() #> ─ Session info ─────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.5.0 (2025-04-11) #>  os       Ubuntu 24.04.2 LTS #>  system   x86_64, linux-gnu #>  ui       X11 #>  language en #>  collate  C.UTF-8 #>  ctype    C.UTF-8 #>  tz       UTC #>  date     2025-06-05 #>  pandoc   3.1.11 @ /opt/hostedtoolcache/pandoc/3.1.11/x64/ (via rmarkdown) #>  quarto   NA #>  #> ─ Packages ─────────────────────────────────────────────────────────────────── #>  package     * version    date (UTC) lib source #>  bookdown      0.43       2025-04-15 [1] RSPM #>  bslib         0.9.0      2025-01-30 [1] RSPM #>  cachem        1.1.0      2024-05-16 [1] RSPM #>  cli           3.6.5      2025-04-23 [1] RSPM #>  desc          1.4.3      2023-12-10 [1] RSPM #>  devtools      2.4.5      2022-10-11 [1] RSPM #>  digest        0.6.37     2024-08-19 [1] RSPM #>  ellipsis      0.3.2      2021-04-29 [1] RSPM #>  evaluate      1.0.3      2025-01-10 [1] RSPM #>  fastmap       1.2.0      2024-05-15 [1] RSPM #>  fs            1.6.6      2025-04-12 [1] RSPM #>  glue          1.8.0      2024-09-30 [1] RSPM #>  htmltools     0.5.8.1    2024-04-04 [1] RSPM #>  htmlwidgets   1.6.4      2023-12-06 [1] RSPM #>  httpuv        1.6.16     2025-04-16 [1] RSPM #>  jquerylib     0.1.4      2021-04-26 [1] RSPM #>  jsonlite      2.0.0      2025-03-27 [1] RSPM #>  knitr         1.50       2025-03-16 [1] RSPM #>  later         1.4.2      2025-04-08 [1] RSPM #>  lifecycle     1.0.4      2023-11-07 [1] RSPM #>  magrittr      2.0.3      2022-03-30 [1] RSPM #>  memoise       2.0.1      2021-11-26 [1] RSPM #>  mime          0.13       2025-03-17 [1] RSPM #>  miniUI        0.1.2      2025-04-17 [1] RSPM #>  pkgbuild      1.4.8      2025-05-26 [1] RSPM #>  pkgdown       2.1.3      2025-05-25 [1] RSPM #>  pkgload       1.4.0      2024-06-28 [1] RSPM #>  profvis       0.4.0      2024-09-20 [1] RSPM #>  promises      1.3.3      2025-05-29 [1] RSPM #>  purrr         1.0.4      2025-02-05 [1] RSPM #>  R6            2.6.1      2025-02-15 [1] RSPM #>  ragg          1.4.0      2025-04-10 [1] RSPM #>  Rcpp          1.0.14     2025-01-12 [1] RSPM #>  remotes       2.5.0      2024-03-17 [1] RSPM #>  rlang         1.1.6      2025-04-11 [1] RSPM #>  rmarkdown     2.29       2024-11-04 [1] RSPM #>  sass          0.4.10     2025-04-11 [1] RSPM #>  sessioninfo   1.2.3      2025-02-05 [1] RSPM #>  shiny         1.10.0     2024-12-14 [1] RSPM #>  systemfonts   1.2.3      2025-04-30 [1] RSPM #>  textshaping   1.0.1      2025-05-01 [1] RSPM #>  urlchecker    1.0.1      2021-11-30 [1] RSPM #>  usethis       3.1.0      2024-11-26 [1] RSPM #>  UWBiost561  * 0.0.0.9000 2025-06-05 [1] local #>  vctrs         0.6.5      2023-12-01 [1] RSPM #>  xfun          0.52       2025-04-02 [1] RSPM #>  xtable        1.8-4      2019-04-21 [1] RSPM #>  yaml          2.3.10     2024-07-26 [1] RSPM #>  #>  [1] /home/runner/work/_temp/Library #>  [2] /opt/R/4.5.0/lib/R/site-library #>  [3] /opt/R/4.5.0/lib/R/library #>  * ── Packages attached to the search path. #>  #> ──────────────────────────────────────────────────────────────────────────────"},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"q5-storyline-for-hw4-and-final-project","dir":"Articles","previous_headings":"","what":"Q5: Storyline for HW4 and final project","title":"BIOST 561: Homework 3","text":"Intent: intent question prepare HW4 final project. Please read: expect HW4: HW4, curating every student’s implementation compute_maximal_partial_clique() provide one folder contains every student’s (anonymized) implementation. , : code review two different implementations assign specifically (involves reading code well seeing implementations pass unit tests) Performing modest simulation study compares implementations terms 1) size maximal partial clique found, 2) time takes complete, 3) often crashes gives invalid output. Bayes (Biostat servers). reason, strongly encourage take diligence testing code since every student soon trying implementation simulated adjacency matrices. Question 5A: Please make sure can install Husky OnNet use UW VPN. installation instructions : https://uwconnect.uw.edu/?id=kb_article_view&sysparm_article=KB0034247 useful links: Instructions wrote lab: https://docs.google.com/document/d/1FGdD3O7nL-xQfPRefHb9fxmqf43HYHGLgD-V4UZC6ec/edit?usp=sharing https://uwconnect.uw.edu/?id=kb_article_view&sysparm_article=KB0034243 – talks exactly ’re downloading. Question 5B: sentences, please describe think ’d like make final project. 100% okay “reuse” R code another course (either past current, even previous institution). Ideally, R code care . write committal – can change idea anytime. intent question get start thinking . summer independent project, going work health department create NLP model can catch certain phrases related overdoses ER notes, 911 calls, EMS case reports. ’d like create simple NLP model familiarity begin summer project. sure ’s case “simple” NLP model ’ll see! full project specifications released weeks. give sense expect, ’ll making PkgDown website looks like https://linnykos.github.io/561_s2025_example/. Briefly, involve: R package includes R code (possibly code languages) solve problem. problem can large small scope want. Unit tests R functions. Documentation exported R functions. vignette explains use R functions. vignette “self-contained” (, include explicit directions downloading data, package R function generate synthetic data). README page explains purpose R package. public PkgDown website R package hosted via GitHub. (can take website grade course submitted.) R project mind, full project specifications give specific directions using UWBiost561 package satisfy requirements. However, experience feel meaningful use something value foundation final project. (project intended take long time. Ideally, choose coding project care foundation final project, already R code, remains “everything else.” care many complex functions . Realistically, can use just meaningful subset functions existing code base project.) Question 5B: Push code onto GitHub. includes contents inside R tests folder DESCRIPTION, NAMESPACE, LICENSE files. Please double-check can see necessary files online GitHub website (.e., https://github.com/). (nothing report question.)","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/articles/HW3.html","id":"q6-feedback-optional","dir":"Articles","previous_headings":"","what":"Q6: Feedback (Optional)","title":"BIOST 561: Homework 3","text":"“question” additional way students communicate instructors. include positive feedback topics enjoyed learning module, critiques course difficulty/pacing, questions/confusions course material. feedback can help shape course rest quarter future years. Please mindful polite providing feedback. may leave question blank.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Breanna Brown. Author, maintainer.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Brown B (2025). UWBiost561: Generate Partial Clique Compute Maximal Partial Clique. R package version 0.0.0.9000, https://brebrown6101.github.io/UWBiost561/.","code":"@Manual{,   title = {UWBiost561: Generate Partial Clique and Compute Maximal Partial Clique},   author = {Breanna Brown},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://brebrown6101.github.io/UWBiost561/}, }"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_correct_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the correct density, given a set of nodes — compute_correct_density","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"define clique_idx length 1 density 1.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_correct_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"","code":"compute_correct_density(adj_mat, clique_idx)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_correct_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"adj_mat symmetric matrix values 0 1, 1's along diagonal, row- column-names, 5 50  rows/columns (inclusive). clique_idx numeric vector index numbers corresponding nodes (.e., values 1 nrow(adj_mat)) function deems maximum partial clique. vector duplicate elements, must positive integers, largest value exceed nrow(adj_mat)","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_correct_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"numeric, density edges among adj_mat[clique_idx,clique_idx]","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"Compute Maximal Partial Clique","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"","code":"compute_maximal_partial_clique(adj_mat, alpha, verbose = FALSE)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"adj_mat symmetric 0/1 adjacency matrix 1s diagonal. alpha numeric threshold 0.5 1 indicating required edge density. verbose Logical; whether print debug output. Default FALSE.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"list : clique_idx Vector node indices maximal partial clique. edge_density Density subgraph induced clique_idx.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"Compute Maximal Partial Clique","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"","code":"compute_maximal_partial_clique1(adj_mat, alpha, verbose = FALSE)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"adj_mat symmetric 0/1 adjacency matrix 1s diagonal. alpha numeric threshold 0.5 1 indicating required edge density. verbose Logical; whether print debug output. Default FALSE.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"list : clique_idx Vector node indices maximal partial clique. edge_density Density subgraph induced clique_idx.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"Given adjacency matrix edge density threshold alpha, function computes maximal partial clique — subset nodes whose induced subgraph edge density least alpha.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"","code":"compute_maximal_partial_clique10(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"adj_mat symmetric binary (0/1) matrix 1s diagonal, row/column names. Must 5 50 rows/columns. alpha single numeric value 0.5 1 (inclusive) specifying minimum required edge density.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"list following elements: clique_idx, numeric vector node indices forming maximal partial clique. edge_density, edge density (0 1) returned clique.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"","code":"adj <- matrix(1, nrow = 6, ncol = 6) adj[1, 2] <- adj[2, 1] <- 0 diag(adj) <- 1 result <- compute_maximal_partial_clique10(adj, 0.9) print(result) #> $clique_idx #> [1] 1 2 3 4 5 6 #>  #> $edge_density #> [1] 0.9333333 #>"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique11","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Determines indices corresponding maximal partial clique adjacency matrix given partial clique density.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"","code":"compute_maximal_partial_clique11(adj_mat, alpha, method = c(\"simple\", \"pivot\"))"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"adj_mat symmetric adjacency matrix 5-50 rows columns. alpha numeric value 0.5 1 (inclusive) indicating minimum fraction edges among nodes outputted partial clique. method One \"simple\" \"pivot\". \"simple\" searches maximal partial clique using modified version original Bron-Kerbosch algorithm, \"pivot\" uses modified version Bron-Kerbosch algorith pivot (Bron & Kerbosch 1973).","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Outputs list containing clique_idx: vector indices form partial clique edge_density: Percentage edges adj_mat among nodes clique_idx.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"function uses modified versions Bron-Kerbosch algorithm, designed compute maximal full cliques, compute maximal partial cliques, allowing users specify \"simple\" \"pivot\" (Bron & Kerbosch 1973). Specifically, alpha < 1, algorithm modified candidate excluded nodes iteration restricted neighbors. Rather, candidate clique initially reported maximal clique satisfies density alpha/2 (help find cliques two nodes alone satisfy alpha density, together clique ), searches final results choose largest clique satisfies alpha. alpha = 1 set, Bron-Kerbosch algorithm applied directly. Using","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Bron, C., & Kerbosch, J. (1973). Algorithm 457: finding cliques undirected graph. Communications ACM, 16(9), 575-577.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":null,"dir":"Reference","previous_headings":"","what":"find maximal partial clique — compute_maximal_partial_clique12","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"find maximal partial clique","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"","code":"compute_maximal_partial_clique12(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"adj_mat matrix look maximal partial clique alpha density partial clique needs reach","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"returns list two things, nodes maximal partial clique, density","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique13","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"Compute maximal partial clique","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"","code":"compute_maximal_partial_clique13(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"adj_mat adj_mat Numeric matrix (n_n) 0/1's, symmetric, 1's diagonal, row/col names, 5:50. alpha Single numeric 0.5 1, minimum required edge-density.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"list clique_idx edge_density","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique function — compute_maximal_partial_clique14","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"function identifies subset nodes binary symmetric adjacency matrix form maximal partial clique edge density least alpha. uses greedy expansion algorithm starting top-k highest-degree nodes iteratively adds nodes maintaining required edge density. However, guarantee best solution every task, limited top-k, especially top-k large matrix size large.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"","code":"compute_maximal_partial_clique14(adj_mat, alpha, top_k_seeds = NULL)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"adj_mat nxn undirected graph 1 meaning connected 0 meaning unconnected. symmetric generated generate_partial_clique_function. n 5 50 inclusive. alpha threshold minimum edge density potential clique. range 0.5 1 inclusive. top_k_seeds value make algorithm efficient setting starter nodes connections. set sqrt number nodes matrix.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"list two elements: clique_idx numeric vector node indices partial clique. edge_density edge density among nodes.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":null,"dir":"Reference","previous_headings":"","what":"Find hte matximal partial clique — compute_maximal_partial_clique15","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"Start first entry, iteratively add nodes. first moment find valid click, stop","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"","code":"compute_maximal_partial_clique15(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"adj_mat graph alpha minimum threshold stop","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"list","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute partial clique — compute_maximal_partial_clique2","title":"Compute partial clique — compute_maximal_partial_clique2","text":"Randomly try bunch cliques return largest one passes threshold","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute partial clique — compute_maximal_partial_clique2","text":"","code":"compute_maximal_partial_clique2(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute partial clique — compute_maximal_partial_clique2","text":"adj_mat adjacency matrix 0,1 alpha minimum edge density","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute partial clique — compute_maximal_partial_clique2","text":"list containing maximum partial clique density","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximum partial clique. — compute_maximal_partial_clique3","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"Compute maximum partial clique.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"","code":"compute_maximal_partial_clique3(adj_mat, alpha, verbose = 0)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"adj_mat Matrix. Adjacency matrix search. alpha Numeric. Minimum edge density potential partial clique. verbose boolean","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"List. clique_idx Nodes found maximum partial clique. edge_density Edge density found clique. alpha.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"function computes approximate maximal partial clique given adjacency matrix, edge density among selected nodes least alpha.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"","code":"compute_maximal_partial_clique4(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"adj_mat symmetric adjacency matrix (0/1) diagonal 1s. alpha numeric value 0.5 1, representing minimum edge density required.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"list following elements: clique_idx numeric vector node indices form partial clique. edge_density edge density among selected nodes (0 1).","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"function attempts find largest subset nodes binary adjacency matrix induced subgraph edge density least alpha. approach uses greedy heuristic: node graph, iteratively adds neighboring nodes increase edge density additions satisfy required threshold. method guarantee global optimum, returns reasonably large dense partial clique within practical time frame.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"","code":"compute_maximal_partial_clique5(adj_mat, alpha, verbose = FALSE)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"adj_mat symmetric binary adjacency matrix 1s diagonal row/col names. alpha numeric scalar 0.5 1. Minimum required edge density. verbose Logical; TRUE, prints progress. Default FALSE.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"list : clique_idx Numeric vector node indices forming partial clique. edge_density actual edge density among nodes.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"final result includes indices selected nodes achieved edge density.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique6","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"function finds reasonably large set nodes graph (represented adjacency matrix) forms partial clique edge density least alpha. uses greedy approach expand highly connected nodes.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"","code":"compute_maximal_partial_clique6(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"adj_mat symmetric binary adjacency matrix diagonal 1s row/column names. alpha numeric value 0.5 1. minimum density required clique.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"list two elements: clique_idx Indices nodes maximal partial clique. edge_density edge density among selected nodes.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"Find maximal partial clique adjacency matrix","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"","code":"compute_maximal_partial_clique7(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"adj_mat symmetric matrix 5 50 rows alpha numeric value 0.5 1","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"list containing clique_idx edge density","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"Compute maximal partial clique function computes maximal partial clique recursively removing node least number edges desired density (alpha) obtained","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"","code":"compute_maximal_partial_clique8(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"adj_mat adjacency matrix edges node . contain least 5 nodes 50. alpha density required partial clique, excluding self-edges.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"list containing index clique clique_idx density clique","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the maximal partial clique — compute_maximal_partial_clique9","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"function finds subset nodes forming partial clique given adjacency matrix edge density among nodes least alpha.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"","code":"compute_maximal_partial_clique9(adj_mat, alpha)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"adj_mat symmetric 0/1 adjacency matrix diagonal values 1, row/column names, size 5 50. alpha single numeric value 0.5 1, specifying required minimum edge density.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"list two elements: clique_idx numeric vector node indices forming identified partial clique. edge_density actual edge density among selected nodes.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"function uses simple greedy algorithm build candidate cliques returns largest one finds satisfies density threshold.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":null,"dir":"Reference","previous_headings":"","what":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"function runs implementation (dictated number) using inputs adj_mat alpha. example, compute_maximal_partial_clique_master(adj_mat, alpha, number = 5) executes compute_maximal_partial_clique5(adj_mat, alpha).","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"","code":"compute_maximal_partial_clique_master(adj_mat, alpha, number, time_limit = 30)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"adj_mat symmetric matrix values 0 1, 1's along diagonal, row- column-names, 5 50  rows/columns (inclusive) alpha single numeric (.e., length 1), value 0.5 1 (inclusive) number implementation number use time_limit number seconds implementation times ","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"list clique_idx, edge_density (implementation ) status valid (added function)","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"implementation errors (.e., crashes), output status error. implementation complete within time_limit number seconds (.e., took long), output status timed_out. valid output boolean whether provided clique_idx forms valid partial clique. method status timed_out error, method (default) valid=FALSE.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/generate_partial_clique.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a random adjacency matrix with a partial clique — generate_partial_clique","title":"Generate a random adjacency matrix with a partial clique — generate_partial_clique","text":"Generate random adjacency matrix partial clique","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/generate_partial_clique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a random adjacency matrix with a partial clique — generate_partial_clique","text":"","code":"generate_partial_clique(n, clique_fraction, clique_edge_density, seed = NULL)"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/generate_partial_clique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a random adjacency matrix with a partial clique — generate_partial_clique","text":"n Integer. Number nodes graph. clique_fraction Numeric 0 1. Fraction nodes partial clique. clique_edge_density Numeric 0 1. Edge density within partial clique. seed Optional integer. Random seed reproducibility.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/generate_partial_clique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a random adjacency matrix with a partial clique — generate_partial_clique","text":"list least one element: adj_mat symmetric binary adjacency matrix partial clique.","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/maximal_partial_clique_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a simulation of maximal partial clique computing implementations — maximal_partial_clique_sim","title":"Run a simulation of maximal partial clique computing implementations — maximal_partial_clique_sim","text":"Run simulation maximal partial clique computing implementations","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/maximal_partial_clique_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a simulation of maximal partial clique computing implementations — maximal_partial_clique_sim","text":"","code":"maximal_partial_clique_sim(   imp_numbers = 1:15,   trials = 4,   alpha_vec = c(0.5, 0.75, 0.95),   n_vec = c(10, 25, 45) )"},{"path":"https://brebrown6101.github.io/UWBiost561/reference/maximal_partial_clique_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a simulation of maximal partial clique computing implementations — maximal_partial_clique_sim","text":"imp_numbers number implementations trials number trials ran level per implementation alpha_vec vector alpha levels. Alpha numeric threshold 1 0.5 indicating required edge density n_vec vector n levels. n number nodes graph","code":""},{"path":"https://brebrown6101.github.io/UWBiost561/reference/maximal_partial_clique_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a simulation of maximal partial clique computing implementations — maximal_partial_clique_sim","text":"nested list results level, trial, implementation","code":""}]
